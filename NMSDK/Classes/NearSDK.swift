//
//  NearSDK.swift
//  NMSDK
//
//  Created by Francesco Colleoni on 08/04/16.
//  Copyright Â© 2016 Near srl. All rights reserved.
//

import Foundation
import UIKit
import JWTDecode
import NMNet
import NMJSON
import NMPlug

/// nearit.com iOS SDK
@objc
public class NearSDK: NSObject, Extensible {
    private static let sharedSDK = NearSDK()
    
    private var token = ""
    private var appID: String?
    private var timeoutInterval: NSTimeInterval = 10
    private var consoleOutput = false
    private var forwardCoreEvents = false
    private var corePluginNames = [String]()
    private var pluginHub: PluginHub!
    private var delegate: NearSDKDelegate?
    
    private override init() {
        super.init()
        
        pluginHub = PluginHub(extendedObject: self)
        
        let plugins: [Pluggable] = [
            NPBeaconForest(),
            NPRecipes(),
            NPRecipeReactionSimpleNotification(),
            NPRecipeReactionContent(),
            NPRecipeReactionPoll(),
            NPImageCache()]
        
        for plugin in plugins {
            pluginHub.plug(plugin)
            corePluginNames.append(plugin.name)
        }
    }
    private func resetAppInfo() {
        Console.error(NearSDK.self, text: "Invalid token")
        Console.errorLine("NearSDK.token will be set to \"\"")
        Console.errorLine("NearSDK.appID will be set to nil")
        
        token = ""
        appID = nil
    }
    
    /// The delegate object which will receive SDK's events
    /// The SDK will produce easy to process events
    /// whenever a core plugin will produce an event
    /// Events produced by 3rd party plugins will be
    /// sent to the delegate as they are received
    public class var delegate: NearSDKDelegate? {
        get {
            return sharedSDK.delegate
        }
        set(newDelegate) {
            sharedSDK.delegate = newDelegate
        }
    }
    
    /// Plugin management interface exposed by the SDK
    public class var plugins: PluginHub {
        return sharedSDK.pluginHub
    }
    
    /// The app token linked to an app registered on nearit.com
    /// The token must be a valid JSON Web Token
    public class var token: String {
        get {
            return sharedSDK.token
        }
        set(newToken) {
            if newToken != sharedSDK.token {
                do {
                    let jwt = try decode(newToken)
                    guard let data: [String: AnyObject] = jwt.claim("data") else {
                        sharedSDK.resetAppInfo()
                        return
                    }
                    
                    guard let
                        account = JSON(dictionary: data).json("account"),
                        identifier = account.string("id"),
                        role = account.string("role_key") where role.lowercaseString == "app" else {
                            sharedSDK.resetAppInfo()
                            return
                    }
                    
                    sharedSDK.token = newToken
                    sharedSDK.appID = identifier
                }
                catch _ {
                    sharedSDK.resetAppInfo()
                }
            }
        }
    }
    /// The app identifier defined by NearSDK.token
    public class var appID: String? {
        return sharedSDK.appID
    }
    /// The timeout interval of web requests sent to nearit.com servers
    /// The default value is 10 seconds
    /// This value must be greater than 0
    /// Assigning a value less than or equal to 0
    /// will reset the timeout interval to 10 seconds
    public class var timeoutInterval: NSTimeInterval {
        get {
            return sharedSDK.timeoutInterval
        }
        set(newTimeoutInterval) {
            sharedSDK.timeoutInterval = (newTimeoutInterval <= 0 ? 10 : newTimeoutInterval)
        }
    }
    /// If true, NearSDK will output some informations on Xcode's console (default value is false)
    public class var consoleOutput: Bool {
        get {
            return sharedSDK.consoleOutput
        }
        set(newFlag) {
            sharedSDK.consoleOutput = newFlag
        }
    }
    /// If true, all events generated by core plugins
    /// will be forwarded to delegate "as-is", otherwise
    /// they will be silenced - the delegate will not receive any of these events
    public class var forwardCoreEvents: Bool {
        get {
            return sharedSDK.forwardCoreEvents
        }
        set(newFlag) {
            sharedSDK.forwardCoreEvents = newFlag
        }
    }
    /// The names of the core plugins used by NearSDK
    public class var corePluginNames: [String] {
        return sharedSDK.corePluginNames
    }
    
    /// MARK: Management of core plugins used by the SDK
    /// Starts the SDK
    /// If token is defined, it will be used by the SDK
    /// If token is not defined, a token must be configured in app's
    /// Info.plist for key NearSDKToken, otherwise this method will fail (NearSDK will not start)
    public class func start(token token: String? = nil) -> Bool {
        // token is defined
        if let aToken = token {
            NearSDK.token = aToken
            return startCorePlugins()
        }
        
        // token is not defined (nil): use value NearSDKToken configured in app's Info.plist
        guard let aToken = NSBundle.mainBundle().objectForInfoDictionaryKey("NearSDKToken") as? String else {
            delegate?.nearSDKDidFail?(
                error: NearSDKError.TokenNotFoundInAppConfiguration,
                message: "A valid token must be configured in app's Info.plist for key \"NearSDKToken\": it must be linked to an app registered on nearit.com")
            
            Console.error(NearSDK.self, text: "Cannot start NearSDK")
            Console.errorLine("NearSDKToken key not found in app's Info.plist")
            Console.errorLine("Add NearSDKToken key to app's Info.plist or start NearSDK by calling NearSDK(token:)")
            return false
        }
        
        NearSDK.token = aToken
        return startCorePlugins()
    }
    private class func startCorePlugins() -> Bool {
        var result = true
        
        let pluginsToRun = [
            "com.nearit.sdk.plugin.np-beacon-monitor",
            "com.nearit.sdk.plugin.np-recipes",
            "com.nearit.sdk.plugin.np-recipe-reaction-content",
            "com.nearit.sdk.plugin.np-recipe-reaction-simple-notification",
            "com.nearit.sdk.plugin.np-recipe-reaction-poll",
        ]
        let arguments = JSON(dictionary: ["do": "sync", "app-token": token, "timeout-interval": timeoutInterval])
        
        for plugin in pluginsToRun {
            result = result && (plugins.run(plugin, withArguments: arguments).status == .OK)
            
            if !result {
                Console.error(NearSDK.self, text: "An error occurred while starting NearSDK")
                Console.errorLine("NearSDK core plugin failed to run")
                Console.errorLine("plugin: \(plugin)")
            }
        }
        
        return result
    }
    
    /// Returns some images for a given array of image identifiers
    /// Images which cannot be found will be downloaded and cached
    /// Images which have been already downloaded, will be loaded from the local cache
    public class func imagesWithIdentifiers(identifiers: [String], didFetchImages: ((images: [String: UIImage], downloaded: [String], notFound: [String]) -> Void)?) {
        var fetched = [String: UIImage]()
        var notFound = Set<String>()
        
        if !images(identifiers, storeInto: &fetched, notFound: &notFound) {
            Console.error(NearSDK.self, text: "Cannot find images")
            didFetchImages?(images: fetched, downloaded: [], notFound: identifiers)
            return
        }
        
        if notFound.count <= 0 {
            Console.info(NearSDK.self, text: "Images found (\(fetched.count))")
            didFetchImages?(images: fetched, downloaded: [], notFound: [])
            return
        }
        
        Console.warning(NearSDK.self, text: "Some images cannot be found (\(notFound.count)) ")
        download(notFound, found: fetched) { (images, downloaded, notFound) in
            didFetchImages?(images: images, downloaded: downloaded, notFound: notFound)
        }
    }
    private class func images(identifiers: [String], inout storeInto target: [String: UIImage], inout notFound: Set<String>) -> Bool {
        let response = plugins.run("com.nearit.sdk.plugin.np-image-cache", withArguments: JSON(dictionary: ["do": "read", "identifiers": identifiers]))
        guard let images = response.content.dictionary("images") where response.status == .OK else {
            target.removeAll()
            notFound = Set(identifiers)
            return false
        }
        
        notFound = Set(identifiers)
        for (id, image) in images {
            guard let imageInstance = image as? UIImage else {
                
                continue
            }
            
            notFound.remove(id)
            target[id] = imageInstance
        }
        
        return true
    }
    private class func download(notFound: Set<String>, found: [String: UIImage], completionHandler: ((images: [String: UIImage], downloaded: [String], notFound: [String]) -> Void)?) {
        Console.info(NearSDK.self, text: "Downloading images (\(notFound.count))...")
        MediaAPI.getImages(Array(notFound)) { (images, identifiersNotFound, status) in
            var result = images
            for (id, image) in found {
                result[id] = image
            }
            
            Console.infoLine("downloaded: (\(images.keys.count))")
            Console.infoLine(" not found: (\(identifiersNotFound.count))")
            completionHandler?(images: result, downloaded: Array(images.keys), notFound: identifiersNotFound)
        }
    }
    
    /// Clears images' cache
    /// All subsequent calls to NearSDK.imagesWithIdentifiers(_:didFetchImages:) may download images again
    public class func clearImageCache() -> Bool {
        let didClearImageCache = (plugins.run("com.nearit.sdk.plugin.np-image-cache", withArguments: JSON(dictionary: ["do": "clear"])).status == .OK)
        
        if !didClearImageCache {
            Console.error(NearSDK.self, text: "Cannot clear images' cache")
        }
        
        return didClearImageCache
    }
    
    /// MARK: NMPlug.Extensible
    public func didReceivePluginEvent(event: PluginEvent) {
        manageRecipeReaction(event)
        manageCoreEventForwarding(event)
    }
    private func manageRecipeReaction(event: PluginEvent) {
        switch event.from {
        case "com.nearit.sdk.plugin.np-recipes":
            guard let content = event.content.json("content"), type = event.content.string("type") else {
                return
            }
            
            manageReaction(content, type: type)
        default:
            break
        }
    }
    private func manageReaction(content: JSON, type: String) {
        switch type {
        case "content-notification":
            if let object = APRecipeContent(dictionary: content.dictionary) {
                delegate?.nearSDKDidEvaluate?(contents: [Content(content: object)])
            }
        case "simple-notification":
            if let object = APRecipeNotification(dictionary: content.dictionary) {
                delegate?.nearSDKDidEvaluate?(notifications: [Notification(notification: object)])
            }
        case "poll-notification":
            if let object = APRecipePoll(dictionary: content.dictionary) {
                delegate?.nearSDKDidEvaluate?(polls: [Poll(poll: object)])
            }
        default:
            break
        }
    }
    private func manageCoreEventForwarding(event: PluginEvent) {
        // Errors should be examined first
        if manageError(event) {
            return
        }
        
        // Non-error events may be discarded
        if corePluginNames.contains(event.from) && !forwardCoreEvents {
            return
        }
        
        // Non-blocked events will be forwarded to delegate
        delegate?.nearSDKDidReceiveEvent?(event)
    }
    private func manageError(event: PluginEvent) -> Bool {
        if let errorValue = event.content.int("error"), error = NearSDKError(rawValue: errorValue), message = event.content.string("message") {
            delegate?.nearSDKDidFail?(error: error, message: message)
            return true
        }
        
        return false
    }
}
